// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/Target.sol";

/// @title UniversalExploit
/// @notice Generic harness that reads exploit_data.json and executes an attack
contract UniversalExploit is Test {
    Target public target;

    struct AttackStep {
        bytes callData;
        uint256 value;
    }

    AttackStep[] internal steps;
    address internal expectedOwner;

    function setUp() public {
        // In MVP we just deploy a fresh Target locally.
        // Later you can swap this for different targets / deployed bytecode.
        target = new Target();

        // Give the test contract some ETH to forward if needed.
        vm.deal(address(this), 100 ether);

        // Load exploit data from JSON written by the Python agent.
        string memory json = vm.readFile("./exploit_data.json");

        // Steps: array of { callData, value }
        bytes memory rawSteps = vm.parseJson(json, ".steps");
        AttackStep[] memory decoded = abi.decode(rawSteps, (AttackStep[]));

        for (uint256 i = 0; i < decoded.length; i++) {
            steps.push(decoded[i]);
        }

        // Optional expectedOwner field – if not present, this will revert,
        // so in early MVP you can omit it from JSON or wrap in try/catch.
        // For now we assume JSON includes `"expectedOwner": "0x..."`
        try this._loadExpectedOwner(json) {
            // ok
        } catch {
            // no expectedOwner provided – ignore
        }
    }

    function _loadExpectedOwner(string memory json) external {
        bytes memory rawOwner = vm.parseJson(json, ".expectedOwner");
        expectedOwner = abi.decode(rawOwner, (address));
    }

    function testRunExploit() public {
        address attacker = address(0xBAD);

        // Snapshot before
        address ownerBefore = target.owner();
        uint256 balanceBefore = address(target).balance;

        console.log("[-] State Before:");
        console.log("    Owner   :", ownerBefore);
        console.log("    Balance :", balanceBefore);

        vm.startPrank(attacker);
        for (uint256 i = 0; i < steps.length; i++) {
            (bool success, ) = address(target).call{value: steps[i].value}(steps[i].callData);
            require(success, "Exploit Step Failed");
        }
        vm.stopPrank();

        // Snapshot after
        address ownerAfter = target.owner();
        uint256 balanceAfter = address(target).balance;

        console.log("[+] State After:");
        console.log("    Owner   :", ownerAfter);
        console.log("    Balance :", balanceAfter);

        // Basic invariant checks – loosen/tighten as needed
        if (expectedOwner != address(0)) {
            assertEq(ownerAfter, expectedOwner, "Owner did not match expected attacker");
        }

        // Example “we won” condition: owner changed
        require(ownerAfter != ownerBefore, "Owner did not change – exploit likely failed");
    }
}
